<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <title>Stlite app</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@stlite/browser@0.89.1/build/stlite.css"
    />
  </head>
  <body>
    <div id="root"></div>
    <script type="module">
import { mount } from "https://cdn.jsdelivr.net/npm/@stlite/browser@0.89.1/build/stlite.js"
mount(
  {
    requirements: [],
    entrypoint: "streamlit_app.py",
    files: {
"streamlit_app.py": `import streamlit as st
import itertools
from collections import defaultdict, deque
import random
import base64
import streamlit.components.v1 as components

st.set_page_config(page_title="Pickleball Rotations", page_icon="ðŸŽ¾", layout="centered")

# ---------- Copy-to-clipboard (single button) ----------
def _b64(s: str) -> str:
    return base64.b64encode(s.encode("utf-8")).decode("ascii")

def _lighten(hex_color: str, factor: float = 0.25) -> str:
    """Lighten a hex color by mixing with white."""
    h = hex_color.lstrip("#")
    r, g, b = (int(h[i:i+2], 16) for i in (0, 2, 4))
    r = int(r + (255 - r) * factor)
    g = int(g + (255 - g) * factor)
    b = int(b + (255 - b) * factor)
    return f"#{r:02x}{g:02x}{b:02x}"

def copy_full_button(text: str, key: str = "copy_full", label: str = "ðŸ“‹ Copy full schedule"):
    payload = _b64(text)
    primary = (st.get_option("theme.primaryColor") or "#4F8BF9").strip()
    lighter = _lighten(primary, 0.35)

    html = f'''
<style>
  .copywrap {{
    margin-top: 12px;
    text-align: center;
  }}
  #{key} {{
    background: linear-gradient(90deg, {primary}, {lighter});
    color: #fff;
    border: none;
    padding: 10px 18px;
    font-size: 16px;
    border-radius: 10px;
    cursor: pointer;
    transition: transform .2s ease, box-shadow .2s ease;
    box-shadow: 0 2px 5px rgba(0,0,0,.15);
  }}
  #{key}:hover {{
    transform: scale(1.03);
    box-shadow: 0 3px 8px rgba(0,0,0,.25);
  }}
  #{key}-msg {{
    margin-top: 8px;
    font-size: .9rem;
    color: #666;
    text-align: center;
  }}
</style>

<div class="copywrap">
  <button id="{key}">{label}</button>
  <div id="{key}-msg"></div>
</div>

<script>
(function() {{
  const btn = document.getElementById("{key}");
  const msg = document.getElementById("{key}-msg");
  const b64 = "{payload}";

  function utf8FromBase64(b64) {{
    const bin = atob(b64);
    const bytes = new Uint8Array(Array.from(bin, c => c.charCodeAt(0)));
    try {{
      return new TextDecoder("utf-8").decode(bytes);
    }} catch (e) {{
      return decodeURIComponent(escape(bin));
    }}
  }}

  const txt = utf8FromBase64(b64);

  btn.addEventListener("click", async () => {{
    try {{
      await navigator.clipboard.writeText(txt);
      msg.textContent = "âœ… Copied!";
      msg.style.color = "{primary}";
      setTimeout(() => {{ msg.textContent = ""; }}, 1500);
    }} catch (e) {{
      msg.textContent = "âŒ Copy failed";
      msg.style.color = "red";
      setTimeout(() => {{ msg.textContent = ""; }}, 1500);
    }}
  }});
}})();
</script>
'''
    components.html(html, height=110)

# ---------- Rotation logic ----------
def schedule_rotations(players, num_courts, num_rounds, seed=None):
    if seed is not None:
        random.seed(seed)

    players = [p.strip() for p in players if p.strip()]
    if len(players) < 4:
        raise ValueError("Need at least 4 players.")

    per_round_capacity = 4 * num_courts
    random.shuffle(players)
    play_queue = deque(players)

    teammate_count = defaultdict(int)
    opponent_count = defaultdict(int)
    plays_count = defaultdict(int)
    bench_count = defaultdict(int)

    rounds, benches = [], []

    for _ in range(num_rounds):
        round_players = []
        while len(round_players) < min(per_round_capacity, len(players)) and len(round_players) < len(players):
            p = play_queue.popleft()
            round_players.append(p)
            play_queue.append(p)

        target_matches = min(num_courts, len(round_players) // 4) if len(round_players) >= 4 else 0
        candidate_pairs = list(itertools.combinations(round_players, 2))

        used_this_round = set()
        chosen_pairs = []

        def pair_score(a, b):
            return (teammate_count[frozenset((a, b))], (plays_count[a] + plays_count[b]) / 2.0)

        for _ in range(2 * target_matches):
            viable = [(pair_score(a, b), (a, b)) for (a, b) in candidate_pairs
                      if a not in used_this_round and b not in used_this_round]
            if not viable:
                break
            viable.sort(key=lambda x: x[0])
            _, (a, b) = viable[0]
            chosen_pairs.append((a, b))
            used_this_round.update([a, b])

        matches = []
        pairs_pool = set(tuple(sorted(p)) for p in chosen_pairs)

        def match_score(pair1, pair2):
            a, b = pair1
            c, d = pair2
            return (opponent_count[frozenset((a, c))] + opponent_count[frozenset((a, d))] +
                    opponent_count[frozenset((b, c))] + opponent_count[frozenset((b, d))])

        while len(pairs_pool) >= 2 and len(matches) < target_matches:
            pool_list = sorted(list(pairs_pool),
                               key=lambda p: (teammate_count[frozenset(p)], (plays_count[p[0]] + plays_count[p[1]]) / 2.0))
            p1 = pool_list[0]
            best, best_score = None, None
            for p2 in pool_list[1:]:
                if not (set(p1) & set(p2)):
                    s = match_score(p1, p2)
                    if best is None or s < best_score:
                        best, best_score = p2, s
            if best is None:
                pairs_pool.remove(p1)
                continue
            matches.append((p1, best))
            pairs_pool.remove(p1)
            pairs_pool.remove(best)

        active_players = set()
        for ((a, b), (c, d)) in matches:
            teammate_count[frozenset((a, b))] += 1
            teammate_count[frozenset((c, d))] += 1
            for x in (a, b, c, d):
                plays_count[x] += 1
                active_players.add(x)
            for x in (a, b):
                for y in (c, d):
                    opponent_count[frozenset((x, y))] += 1

        benched = [p for p in players if p not in active_players]
        benches.append(benched)
        for b in benched:
            bench_count[b] += 1

        if benched:
            current = list(play_queue)
            benched_set = set(benched)
            play_queue = deque([p for p in current if p in benched_set] + [p for p in current if p not in benched_set])

        rounds.append(matches)

    stats = {
        "teammates": dict(teammate_count),
        "opponents": dict(opponent_count),
        "plays": dict(plays_count),
        "benches": dict(bench_count),
    }
    return rounds, benches, stats

def format_round(round_matches):
    return [f"{a} & {b} vs {c} & {d}" for ((a, b), (c, d)) in round_matches]

def schedule_to_share_text(players, rounds, benches):
    lines = []
    lines.append("ðŸŽ¾ Pickleball Rotations")
    lines.append(f"Players ({len(players)}): " + ", ".join(players))
    lines.append("")
    for i, (matches, benched) in enumerate(zip(rounds, benches), start=1):
        lines.append(f"Round {i}:")
        if matches:
            for ((a, b), (c, d)) in matches:
                lines.append(f"  â€¢ {a} & {b} vs {c} & {d}")
        else:
            lines.append("  â€¢ No full matches possible")
        if benched:
            lines.append("  (Benched: " + ", ".join(benched) + ")")
        if i != len(rounds):
            lines.append("")
    return "\\n".join(lines)

# ---------- UI ----------
st.title("ðŸŽ¾ Pickleball Player Rotation Generator")

player_input = st.text_area(
    "Enter player names (one per line or comma-separated):",
    placeholder="Alice, Bob, Charlie, Dana, Evan, Fiona, ...",
    height=150,
)

c1, c2, c3 = st.columns(3)
with c1:
    num_courts = st.number_input("Number of courts", 1, 10, 2, 1)
with c2:
    num_rounds = st.number_input("Number of rounds", 1, 50, 8, 1)
with c3:
    seed_text = st.text_input("Random seed (optional)")

if st.button("Generate Rotations"):
    if not player_input.strip():
        st.error("Please enter at least 4 player names.")
    else:
        players = [p.strip() for chunk in player_input.splitlines() for p in chunk.split(",") if p.strip()]
        if len(players) < 4:
            st.error("Please enter at least 4 players.")
        else:
            # Seed handling
            seed = None
            if seed_text.strip():
                try:
                    seed = int(seed_text.strip())
                except ValueError:
                    seed = abs(hash(seed_text.strip())) % (2**32)

            rounds, benches, stats = schedule_rotations(players, num_courts, num_rounds, seed=seed)

            st.subheader("Schedule")
            for i, (matches, benched) in enumerate(zip(rounds, benches), start=1):
                st.markdown(f"**Round {i}**")
                if matches:
                    for line in format_round(matches):
                        st.write(line)
                else:
                    st.write("_No full matches possible this round._")
                if benched:
                    st.caption("Benched: " + ", ".join(benched))
                st.markdown("---")

            # Single copy button for the full schedule (visible & working)
            full_text = schedule_to_share_text(players, rounds, benches)
            copy_full_button(full_text)

            with st.expander("Diagnostics (optional)"):
                st.json(stats)
`,

},
  },
  document.getElementById("root")
)

    </script>
  </body>
  <!-- Generated from Stlite Sharing (https://edit.share.stlite.net/), and the source version is 3e818f3f4a6ded7d39732a794935234b3d5d527c -->
</html>
