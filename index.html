<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <title>Stlite app</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@stlite/browser@0.89.1/build/stlite.css"
    />
  </head>
  <body>
    <div id="root"></div>
    <script type="module">
import { mount } from "https://cdn.jsdelivr.net/npm/@stlite/browser@0.89.1/build/stlite.js"
mount(
  {
    requirements: [],
    entrypoint: "streamlit_app.py",
    files: {
"streamlit_app.py": `import streamlit as st
import itertools
from collections import defaultdict, deque
import random

st.set_page_config(page_title="Pickleball Rotations", page_icon="ðŸŽ¾", layout="centered")

# ----------------------------
# Scheduling core
# ----------------------------

def schedule_rotations(players, num_courts, num_rounds, seed=None):
    """
    Build rounds of doubles matches for multiple courts, minimizing repeat teammates and
    balancing play time. Works with odd counts by rotating benches fairly.

    Returns:
        rounds: list of rounds; each round is list of matches; each match is ((p1,p2),(p3,p4))
        benches: list of benched players per round (could be empty list)
        stats: dict of counts (teammates/opponents/plays/benches) for diagnostics
    """
    if seed is not None:
        random.seed(seed)

    players = [p.strip() for p in players if p.strip()]
    n = len(players)
    if n < 4:
        raise ValueError("Need at least 4 players.")

    per_round_capacity = 4 * num_courts
    random.shuffle(players)
    play_queue = deque(players)

    teammate_count = defaultdict(int)      # key: frozenset({a,b})
    opponent_count = defaultdict(int)      # key: frozenset({a,b})
    plays_count = defaultdict(int)         # key: player
    bench_count = defaultdict(int)         # key: player

    rounds = []
    benches = []

    for _ in range(num_rounds):
        # Choose who is eligible this round (fill capacity; others initially "eligible bench")
        round_players = []
        while len(round_players) < min(per_round_capacity, n) and len(round_players) < n:
            p = play_queue.popleft()
            round_players.append(p)
            play_queue.append(p)

        # Target number of matches we can actually run this round
        target_matches = min(num_courts, len(round_players) // 4) if len(round_players) >= 4 else 0

        # Build candidate pairs from round players
        candidate_pairs = list(itertools.combinations(round_players, 2))

        used_this_round = set()
        chosen_pairs = []

        def pair_score(a, b):
            # lower is better
            t = teammate_count[frozenset((a, b))]
            bal = (plays_count[a] + plays_count[b]) / 2.0
            return (t, bal)

        # Pick just enough pairs to form target_matches (2 pairs per match)
        for _ in range(2 * target_matches):
            viable = [(pair_score(a, b), (a, b)) for (a, b) in candidate_pairs
                      if a not in used_this_round and b not in used_this_round]
            if not viable:
                break
            viable.sort(key=lambda x: x[0])
            _, (a, b) = viable[0]
            chosen_pairs.append((a, b))
            used_this_round.update([a, b])

        # Turn pairs into matches, minimizing opponent repeats
        matches = []
        pairs_pool = set(tuple(sorted(p)) for p in chosen_pairs)

        def match_score(pair1, pair2):
            a, b = pair1
            c, d = pair2
            return (opponent_count[frozenset((a, c))] + opponent_count[frozenset((a, d))] +
                    opponent_count[frozenset((b, c))] + opponent_count[frozenset((b, d))])

        while len(pairs_pool) >= 2 and len(matches) < target_matches:
            pool_list = list(pairs_pool)
            pool_list.sort(key=lambda p: (teammate_count[frozenset(p)],
                                          (plays_count[p[0]] + plays_count[p[1]]) / 2.0))
            p1 = pool_list[0]

            best = None
            best_score = None
            for p2 in pool_list[1:]:
                if not (set(p1) & set(p2)):
                    s = match_score(p1, p2)
                    if best is None or s < best_score:
                        best = p2
                        best_score = s

            if best is None:
                pairs_pool.remove(p1)
                continue

            matches.append((p1, best))
            pairs_pool.remove(p1)
            pairs_pool.remove(best)

        # Update counts for plays/teammates/opponents
        active_players = set()
        for ((a, b), (c, d)) in matches:
            teammate_count[frozenset((a, b))] += 1
            teammate_count[frozenset((c, d))] += 1

            for x in (a, b, c, d):
                plays_count[x] += 1
                active_players.add(x)

            for x in (a, b):
                for y in (c, d):
                    opponent_count[frozenset((x, y))] += 1

        # Players who did NOT play in a match this round are benched (regardless of eligibility selection)
        benched = [p for p in players if p not in active_players]
        benches.append(benched)
        for b in benched:
            bench_count[b] += 1

        # Fairness tweak: bring benched players to the front of the queue for next round
        if benched:
            current = list(play_queue)
            benched_set = set(benched)
            new_order = [p for p in current if p in benched_set] + [p for p in current if p not in benched_set]
            play_queue = deque(new_order)

        rounds.append(matches)

    stats = {
        "teammates": dict(teammate_count),
        "opponents": dict(opponent_count),
        "plays": dict(plays_count),
        "benches": dict(bench_count),
    }
    return rounds, benches, stats


def format_round(round_matches):
    lines = []
    for (team1, team2) in round_matches:
        (a, b) = team1
        (c, d) = team2
        lines.append(f"{a} & {b} vs {c} & {d}")
    return lines


# ----------------------------
# Streamlit UI
# ----------------------------

st.title("ðŸŽ¾ Pickleball Player Rotation Generator")

with st.expander("How it works"):
    st.write(
        """
        - Works for **any number of players â‰¥ 4** and **any number of courts**.
        - If players arenâ€™t a multiple of 4Ã—courts, the app **fairly rotates benches** each round.
        - Each round is built with a heuristic to **minimize repeat teammates** and also reduce repeat opponents.
        - You can set a random seed for reproducibility, or leave it blank for fresh schedules.
        """
    )

player_input = st.text_area(
    "Enter player names (one per line or comma-separated):",
    placeholder="Alice, Bob, Charlie, Dana, Evan, Fiona, ...",
    height=150,
)

col1, col2, col3 = st.columns(3)
with col1:
    num_courts = st.number_input("Number of courts", min_value=1, max_value=10, value=2, step=1)
with col2:
    num_rounds = st.number_input("Number of rounds", min_value=1, max_value=50, value=8, step=1)
with col3:
    seed_text = st.text_input("Random seed (optional)", value="")

if st.button("Generate Rotations"):
    if not player_input.strip():
        st.error("Please enter at least 4 player names.")
    else:
        raw = [p.strip() for chunk in player_input.splitlines() for p in chunk.split(",")]
        players = [p for p in raw if p]

        if len(players) < 4:
            st.error("Please enter at least 4 players.")
        else:
            max_matches_possible = len(players) // 4
            if num_courts > max_matches_possible and max_matches_possible > 0:
                st.warning(
                    f"You have {len(players)} players; at most {max_matches_possible} match(es) "
                    f"can run simultaneously. Iâ€™ll schedule up to that many courts per round."
                )

            seed = None
            if seed_text.strip():
                try:
                    seed = int(seed_text.strip())
                except ValueError:
                    seed = abs(hash(seed_text.strip())) % (2**32)

            rounds, benches, stats = schedule_rotations(players, num_courts, num_rounds, seed=seed)

            st.subheader("Schedule")
            for i, (matches, benched) in enumerate(zip(rounds, benches), start=1):
                st.markdown(f"**Round {i}**")
                if not matches:
                    st.write("_No full matches possible this round with the current settings._")
                for line in format_round(matches):
                    st.write(line)
                if benched:
                    st.caption("Benched: " + ", ".join(benched))
                st.markdown("---")

            with st.expander("Diagnostics (teammates, opponents, plays, benches)"):
                tm = sorted(((tuple(sorted(k)), v) for k, v in stats["teammates"].items() if v > 0),
                            key=lambda x: (-x[1], x[0]))
                if tm:
                    st.write("Top teammate repeats:")
                    st.write(", ".join([f"{a}&{b}:{v}" for (a, b), v in tm[:20]]))

                op = sorted(((tuple(sorted(k)), v) for k, v in stats["opponents"].items() if v > 0),
                            key=lambda x: (-x[1], x[0]))
                if op:
                    st.write("Top opponent repeats:")
                    st.write(", ".join([f"{a}vs{b}:{v}" for (a, b), v in op[:20]]))

                if stats["plays"]:
                    st.write("Plays per player:")
                    st.write(", ".join([f"{p}:{stats['plays'][p]}" for p in sorted(stats["plays"].keys())]))

                if stats["benches"]:
                    st.write("Bench counts per player:")
                    st.write(", ".join([f"{p}:{stats['benches'][p]}" for p in sorted(stats["benches"].keys())]))

                # Fairness check (plays + benches should equal number of rounds for everyone)
                all_names = sorted(set(list(stats["plays"].keys()) + list(stats["benches"].keys())))
                fairness = [f"{p}: plays={stats['plays'].get(p,0)}, benches={stats['benches'].get(p,0)}, total={stats['plays'].get(p,0)+stats['benches'].get(p,0)}"
                            for p in all_names]
                st.write("Fairness check (plays + benches by player):")
                st.write(", ".join(fairness))`,
"data/logo.png": Uu("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"),
"pages/ðŸŽˆ_subpage.py": `import streamlit as st

st.title("Sub page")

st.markdown("""
_Stlite_ supports **Multi Page Apps (MPA)**, of course!

Create \`pages/*.py\` like this file to add new pages.

If you are new to MPA, read the official tutorial about it [ðŸ”— here](https://docs.streamlit.io/library/get-started/multipage-apps)
""")
`,

},
  },
  document.getElementById("root")
)

function Uu(n){const a=window.atob(n),i=a.length,l=new Uint8Array(i);for(let u=0;u<i;u++)l[u]=a.charCodeAt(u);return l}
    </script>
  </body>
  <!-- Generated from Stlite Sharing (https://edit.share.stlite.net/), and the source version is fb463ba482ecec37a31a01fa95898563625f577b -->
</html>
